"""
Sanitize Fuzz Driver generated by LLM
"""

from loguru import logger
from pathlib import Path
from itertools import chain
import time
import os
import shutil

from src import vars as global_vars
from src.utils import FilePos
from src.llm.prompter import FixBuildPrompter, FixAsanPrompter
from src.analyzer.asan import AsanError
from .driver import FuzzDriver


class DriverRunAttempt:
    """
    Try to run a fuzz driver.
    Used with "with" statement.
    Return the status and message of the run.
    """

    # Whether to cleanup the files after the run
    CLEANUP = False

    # AddressSanitizer options
    ASAN_OPTIONS = ["allocator_may_return_null=1", "allow_user_poisoning=0"]
    # Whether the ASan options are set
    asan_options_set = False

    def set_asan_options(self):
        """
        Set options env for AddressSanitizer
        """
        # This env setting will be used by this process and its children
        options = ":".join(self.ASAN_OPTIONS)
        os.environ["ASAN_OPTIONS"] = options
        self.asan_options_set = True

    def __init__(self, fuzz_driver: FuzzDriver):
        self.fuzz_driver = fuzz_driver
        if not self.asan_options_set:
            # to avoid setting the ASan options multiple times
            self.set_asan_options()

    def __enter__(self):
        # file paths
        suffix = (
            ".cpp"
            if global_vars.library_language == global_vars.SupportedLanguages.CPP
            else ".c"
        )
        self.filename = (
            f"fuzz_driver_{self.fuzz_driver.id}_sanitizing_{int(time.time())}{suffix}"
        )
        self.binname = self.filename.removesuffix(suffix)
        tmp_path = (
            Path(global_vars.library_config["output_path"])
            / "tmp"
            / f"fuzz_driver_{self.fuzz_driver.id}"
        )
        tmp_path.mkdir(parents=True, exist_ok=True)
        self.dest_path = tmp_path

        # run the fuzz driver
        result = self.fuzz_driver.run(
            timeout=1,
            dest_path=self.dest_path,
            filename=self.filename,
            extra_build_args=[
                "-g",
                "-fno-color-diagnostics",
                "-ferror-limit=5",
                "-w",
            ],
            # This arg is for large memory allocation
            # library may malloc the size based on the input data, which may cause OOM or bad-alloc
            # but this is not a problem of the fuzz driver/library itself
            # so we unlimit the memory allocation here
            extra_run_args=["-rss_limit_mb=N"],
            cleanup=False,
        )
        logger.debug(
            f"Execution of fuzz driver {self.fuzz_driver.id} result: {result[0]}, content:\n{result[1][-4000:]}"
        )
        return result

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.CLEANUP:
            # clean up
            shutil.rmtree(self.dest_path)


class Sanitizer:
    """
    Class to sanitize fuzz driver
    """

    # config constants
    CONSOLIDATE_CHAT_HISTORY = True

    DISABLE_FIX = False

    def __init__(self, learner):
        """
        Initialize the sanitizer

        :param learner: The constraint learner
        """
        # import here to avoid circular import
        from .learner import ConstraintLearner

        self.learner: ConstraintLearner = learner

    def fix(self, fuzz_driver: FuzzDriver, err_msg: str, prompter_class):
        """
        Fix fuzz driver code using LLM

        :param fuzz_driver: The fuzz driver
        :param err_msg: The error message
        :param prompter_class: The Prompter class to use, FixBuildPrompter or FixAsanPrompter
        """
        if self.DISABLE_FIX:
            return

        prompter = prompter_class(fuzz_driver.llm_chat)
        fixed_code = prompter.prompt(err_msg)
        if not fixed_code:
            logger.error(
                f"No fixed code generated for fuzz driver {fuzz_driver.id}, skipping..."
            )
            return
        fuzz_driver.fuzz_driver_code = fixed_code
        fuzz_driver.query_count += 1
        if self.CONSOLIDATE_CHAT_HISTORY:
            self._consolidate_chat_history(fuzz_driver)

    def sanitize(self, fuzz_driver: FuzzDriver):
        """
        Try to run sanitization on the fuzz driver once

        :param fuzz_driver: The fuzz driver to be sanitized
        """
        # subtract the remaining sanitization rounds
        fuzz_driver.remain_san_rounds -= 1
        logger.info(
            f"Sanitizing fuzz driver {fuzz_driver.id}, remaining rounds: {fuzz_driver.remain_san_rounds}"
        )

        with DriverRunAttempt(fuzz_driver) as (status, msg):
            match status:
                case "OK":
                    logger.info(
                        f"Sanitization of fuzz driver {fuzz_driver.id} succeeded"
                    )
                    fuzz_driver.sanitized = True
                case "BUILDFAIL":
                    logger.info(
                        f"Build error detected in fuzz driver {fuzz_driver.id}, fixing..."
                    )
                    self.fix(fuzz_driver, msg, FixBuildPrompter)
                case "CRASH":
                    try:
                        asan_err = AsanError(msg)
                    except:
                        logger.error(
                            f"Unknown crash occurred in fuzz driver {fuzz_driver.id}: \n{msg}"
                        )
                    else:
                        # record the ASan error message
                        maybe_learn = self.learner.record_crash(asan_err)
                        if maybe_learn is None:
                            # there is no need to learn the crash, we fix it directly
                            logger.info(
                                f"ASan error detected in fuzz driver {fuzz_driver.id}, fixing..."
                            )
                            self.fix(fuzz_driver, asan_err.readable, FixAsanPrompter)
                        else:
                            # there is a need to learn the crash, we learn it
                            logger.info(
                                f"ASan error detected in fuzz driver {fuzz_driver.id}, which may be a constraint violation, learning..."
                            )
                            if maybe_learn(fuzz_driver):
                                # the ASan error is fixed
                                fuzz_driver.sanitized = True

    @staticmethod
    def _consolidate_chat_history(fuzz_driver: FuzzDriver):
        """
        Consolidate chat history: system prompt - gen prompt - code response 1 - fix prompt - code response 2
        Into: system prompt - gen prompt - code response 2
        """
        if len(fuzz_driver.llm_chat.history) < 5:
            return
        old_history = fuzz_driver.llm_chat.history
        language = (
            "cpp"
            if global_vars.library_language == global_vars.SupportedLanguages.CPP
            else "c"
        )
        new_history = [
            old_history[0],
            old_history[1],
            {
                "role": "assistant",
                "content": f"```{language}\n{fuzz_driver.fuzz_driver_code}\n```",
            },
        ]
        fuzz_driver.llm_chat.history = new_history

    @staticmethod
    def _unused_parse_asan_error(err_msg: str) -> str:
        """
        Extract the readable error message from ASan error message

        :param err_msg: The primary ASan error message
        :return: The readable error message, or an empty string if parsing failed
        """
        # 1. Parse the error type from the error message
        # 2. Parse the error location from the error message
        # 3. Read the exact line of the error in the source code, print it as:
        # fuzz_driver_1.cpp:10:25: Error: AddressSanitizer: heap-buffer-overflow on address 0x502000006a9a at pc 0x5bd859876bde bp 0x7ffe358f22c0 sp 0x7ffe358f1a80
        #    25|    JSON_Value *value = json_value_init_null();
        #      |                        ^

        from parse import search, findall

        # an error line is like:
        # ==4887==ERROR: LeakSanitizer: detected memory leaks
        err_type = search("=={:d}==ERROR: {type}\n", err_msg, case_sensitive=True)
        if err_type is None:
            # try another pattern (This space is stupid, but there are really some cases like this)
            err_type = search("=={:d}== ERROR: {type}\n", err_msg, case_sensitive=True)
            if err_type is None:
                return ""
        err_type = err_type["type"]

        # an error location line is like:
        #     #2 0x64c3e91a8cb6 in LLVMFuzzerTestOneInput /tmp/fuzz_driver_7.cpp:28:25
        err_locs = findall(
            "#{:d} {addr} in LLVMFuzzerTestOneInput {loc}\n",
            err_msg,
            case_sensitive=True,
        )
        err_locs = [_["loc"] for _ in err_locs]

        readable_err_msg = ""
        for err_loc in err_locs:
            try:
                err_pos = FilePos.from_location_line(err_loc)
            except:
                continue
            readable_err_msg += f"{str(err_pos)}: {err_type}\n"
            readable_err_msg += f"{err_pos.line:>6}|{err_pos.cur_line}\n"
            readable_err_msg += f"{" " * 6}|{" " * (err_pos.col - 1)}^\n"

        if not readable_err_msg:
            # There is no error location of source code, just return the error type
            readable_err_msg = err_type

        return readable_err_msg
